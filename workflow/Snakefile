## Check minimum Snakemake version

from snakemake.utils import min_version

min_version("6.0")

## Import required libraries

import os
import glob
import re
import requests
import zipfile
import io

## Configuration check

if len(config) == 0:
    
    sys.exit(
        f"Please specify the path to the input directory with --config INPUT_DIR='path/to/input_directory'."
    )


## Config

INPUT_DIR = os.path.normpath(config["INPUT_DIR"])
BIN_SIZE = config.get("BIN_SIZE", 10000)
FILTER = config.get("FILTER", True)
if not (FILTER is True or FILTER is False or (isinstance(FILTER, str) and len(FILTER) == 1)):
    raise ValueError("Error: FILTER must be either True, False or flags to pass to fastp.")
if isinstance(FILTER, str):
    FILTER_PARAMS = FILTER
    FILTER = True
elif FILTER is True:
    FILTER_PARAMS = "Default"
elif FILTER is False:
    FILTER_PARAMS = "No filtering"
SOFT_CLIP = config.get("SOFT_CLIP", False)
if not isinstance(SOFT_CLIP, bool):
    raise ValueError("Error: SOFT_CLIP must be either True or False.")
SAVE_HEALR_LISTS = config.get("SAVE_HEALR_LISTS", True)
if not isinstance(SOFT_CLIP, bool):
    raise ValueError("Error: SAVE_HEALR_LISTS must be either True or False.")


## Parse Input directory

DATA_TYPE = os.path.basename(INPUT_DIR) # Assumes user named input directory after data type (DNA, RNA, WGBS) unless a config file is provided. 
if DATA_TYPE not in {"DNA", "RNA", "WGBS"}:
    error_msg=f"ERROR: Unknown data type. Name the input directory after the data type: 'DNA', 'RNA' or 'WGBS'."
    raise ValueError(error_msg)
    

SAMPLES = os.listdir(f"{INPUT_DIR}/polyploids") 
PROGENITORS = os.listdir(f"{INPUT_DIR}/progenitors") 

random_sample = SAMPLES[0] # We assume data is either entirely paired or unpaired.

random_sample_dir = os.path.join(INPUT_DIR, "polyploids", random_sample)
# Ensure it's a directory before listing files
if os.path.isdir(random_sample_dir):
    num_files = len(os.listdir(random_sample_dir))
else:
    raise ValueError(f"{random_sample_dir} is not a valid directory!")

if num_files > 2:
    raise ValueError(f"Too many files in {random_sample_dir} ({num_files} found). Expected at most 2.")

if num_files == 2:
    IS_PAIRED = "TRUE"
else:
    IS_PAIRED = "FALSE"

if SAVE_HEALR_LISTS == True:
    save_healr_lists = "TRUE"
else:
    save_healr_lists = "FALSE"

# get all read files
accepted_read_patterns = [
        f"{INPUT_DIR}/polyploids/**/*.fastq",
        f"{INPUT_DIR}/polyploids/**/*.fasta",
        f"{INPUT_DIR}/polyploids/**/*.fna",
        f"{INPUT_DIR}/polyploids/**/*.fq",
        f"{INPUT_DIR}/polyploids/**/*.fa",
        f"{INPUT_DIR}/polyploids/**/*.fastq.gz",
        f"{INPUT_DIR}/polyploids/**/*.fasta.gz",
        f"{INPUT_DIR}/polyploids/**/*.fna.gz",
        f"{INPUT_DIR}/polyploids/**/*.fq.gz",
        f"{INPUT_DIR}/polyploids/**/*.fa.gz",
    ]
all_read_paths = [] 
for pattern in accepted_read_patterns:
        for file in glob.glob(pattern, recursive=True):
            basename = os.path.basename(file)  
            parent_dir = os.path.basename(os.path.dirname(file))  
            all_read_paths.append(os.path.join(parent_dir, basename))


### Make wildcard constraints ###
import re
sample_regex = "|".join(re.escape(sample) for sample in SAMPLES)
progenitor_regex = "|".join(re.escape(progenitor) for progenitor in PROGENITORS)

wildcard_constraints: # limit the value of these wildcards to directory names 
    sample = sample_regex,
    progenitor = progenitor_regex



### Rules ###
include: "rules/bin_gc_map.smk"
include: "rules/healr_analysis.smk"

rule all:
    input:
       "results/HEAL_reproducibility_report.txt"

rule make_reproducibility_report:
    input:
        input_dir=f"{INPUT_DIR}",
        multi_qc="results/MultiQC/multiqc_report.html",
        healr_output="results/healr/stats",
        snake_genespace_report="results/snake_GENESPACE_reproducibility_report.txt",
        snake_eagle_rc_report="results/snake_EAGLE_RC_reproducibility_report.txt"
    output:
        "results/HEAL_reproducibility_report.txt"
    params:
        cores=workflow.cores,
        bin_size=BIN_SIZE,
        filtering=FILTER_PARAMS,
        soft_clip=SOFT_CLIP,
    threads:1
    shell:
        """
        bash {workflow.basedir}/scripts/make_HEAL_reproducibility_report.sh {input.input_dir} \
        {params.cores} \
        {params.bin_size} \
        {params.filtering} \
        {params.soft_clip}
        """


### Import modules ###

## EAGLE-RC

# Get the script and environment files for EAGLE-RC
# Download the ZIP archive of the repo
repo_url = "https://github.com/kenji-yt/snake-EAGLE-RC/archive/refs/heads/main.zip"
response = requests.get(repo_url) 
if response.status_code != 200:
    raise ValueError(f"Failed to download snake-EAGLE-RC repo ZIP. Are you connected to the internet? Status code: {response.status_code}")

# Prepare output paths
envs_output_dir = "results/eagle_rc/envs"
script_output_path = "results/eagle_rc/scripts/make_EAGLE_reproducibility_report.sh"
os.makedirs(envs_output_dir, exist_ok=True)
os.makedirs(os.path.dirname(script_output_path), exist_ok=True)

# Extract only the desired files/directories
with zipfile.ZipFile(io.BytesIO(response.content)) as z:
    found_envs = False
    found_script = False
    for member in z.namelist():
        # Extract files from envs directory (no subdirectories)
        if member.startswith("snake-EAGLE-RC-main/workflow/envs/") and not member.endswith("/"):
            filename = os.path.basename(member)
            target_path = os.path.join(envs_output_dir, filename)
            with open(target_path, "wb") as f:
                f.write(z.read(member))
            found_envs = True
        # Extract the script
        elif member == "snake-EAGLE-RC-main/workflow/scripts/make_EAGLE_reproducibility_report.sh":
            with open(script_output_path, "wb") as f:
                f.write(z.read(member))
            found_script = True

# Check if the extraction was successful
if not found_envs:
    raise ValueError("Failed to extract envs directory from the snake-EAGLE-RC git directory.")
if not found_script or not os.path.isfile(script_output_path):
    raise ValueError("Failed to extract make_EAGLE_reproducibility_report.sh from the snake-EAGLE-RC git directory.")


# Define the EAGLE-RC configuration
eagle_config_values = {
    "INPUT_DIR": f"{INPUT_DIR}",
    "FILTER": FILTER,
    "SOFT_CLIP": SOFT_CLIP,
    "SCRIPTS_DIR": "results/eagle_rc/scripts",
    "ENVS_DIR": "results/eagle_rc/envs",
}

module EAGLE_RC:
    snakefile: # CHANGE REPRODUCIBILITY REPORT IF CHANGING THE TAG
        github("kenji-yt/snake-EAGLE-RC", path="workflow/Snakefile", branch="main") # ,tag="v0.1.1-alpha") Put back tag after 
    config: eagle_config_values

use rule * from EAGLE_RC as eagle_rc_*


## GENESPACE

# Get the script and environment files for EAGLE-RC
# Download the ZIP archive of the repo
repo_url = "https://github.com/kenji-yt/snake-GENESPACE/archive/refs/heads/main.zip"
response = requests.get(repo_url) 
if response.status_code != 200:
    raise ValueError(f"Failed to download snake-GENESPACE repo ZIP. Are you connected to the internet? Status code: {response.status_code}")

# Prepare output paths
scripts_output_dir = "results/genespace/scripts"
os.makedirs(scripts_output_dir, exist_ok=True)

# Extract only the desired files/directories
with zipfile.ZipFile(io.BytesIO(response.content)) as z:
    found_scripts = False
    for member in z.namelist():
        # Extract files from script directory 
        if member.startswith("snake-GENESPACE-main/workflow/scripts/") and not member.endswith("/"):
            filename = os.path.basename(member)
            target_path = os.path.join(scripts_output_dir, filename)
            with open(target_path, "wb") as f:
                f.write(z.read(member))
            found_scripts = True
# Check if the extraction was successful
if not found_scripts:
    raise ValueError("Failed to extract scripts from the snake-EAGLE-RC git directory.")

# Define the GENESPACE configuration
genespace_config_values = {
    "INPUT_DIR": f"{INPUT_DIR}"+"/progenitors",
    "SCRIPTS_DIR": "results/genespace/scripts"
}

module GENESPACE:
    snakefile: 
        github("kenji-yt/snake-GENESPACE", path="workflow/Snakefile", branch="main")#, tag="v0.1.1-alpha")
    config: genespace_config_values

use rule * from GENESPACE as genespace_* 
